{"ast":null,"code":"import { createAction } from \"../../utils/reducer/reducer.utils\";\nimport { CART_ACTION_TYPE } from \"./cart.types\"; // 이곳의 최종 결과물은 액션.  \n// const setData = (date) => createAction (type, data)\n\nexport const setCartItems = item => {\n  createAction(CART_ACTION_TYPE.SET_CART_ITEM, item);\n};\nexport const setIsCartOpen = boolean => createAction(CART_ACTION_TYPE.SET_IS_CART_OPEN, boolean); // main 함수들\n\nconst addCartItem = (productToGo, cartItems) => {\n  const existingProduct = cartItems.find(each => // 기존에 있으면 퀀티티만 추가, 기존에 없으면 새로추가. 항상 배열을 건드릴때는 그 구조에 대해서 생각\n  each.id === productToGo.id);\n\n  if (existingProduct) {\n    // 곂친경우니까 퀀티티만 더해줘야함. 나머지는 그대로 놓고 어떻게 퀀티티만 추가할거냐?\n    return cartItems.map(each => // 맵을 활용할거다. 그래서 있는애면 아이디가 곂칠테니까 걔만 퀀티티+1 나머지는 안건드리고 리턴\n    each.id === productToGo.id ? { ...each,\n      quantity: each.quantity + 1\n    } : each);\n  }\n\n  return [...cartItems, { ...productToGo,\n    quantity: 1\n  }];\n};\n\nconst decreaseCartItem = (theProduct, cartItems) => {\n  if (theProduct.quantity === 1) {\n    return cartItems.filter(item => item.id !== theProduct.id);\n  } else {\n    return cartItems.map(each => each.id === theProduct.id ? { ...each,\n      quantity: each.quantity - 1\n    } : each);\n  }\n};\n\nconst removeCartItem = (theProduct, cartItems) => cartItems.filter(item => item.id !== theProduct.id); // call 함수들 \n\n\nexport const callDecreaseCartItem = (theProduct, cartItems) => {\n  setCartItems(decreaseCartItem(theProduct, cartItems));\n};\nexport const callRemoveCartItem = (theProduct, cartItems) => {\n  setCartItems(removeCartItem(theProduct, cartItems));\n};\nexport const callAddCartItem = (productToGo, cartItems) => {\n  setCartItems(addCartItem(productToGo, cartItems));\n};","map":{"version":3,"names":["createAction","CART_ACTION_TYPE","setCartItems","item","SET_CART_ITEM","setIsCartOpen","boolean","SET_IS_CART_OPEN","addCartItem","productToGo","cartItems","existingProduct","find","each","id","map","quantity","decreaseCartItem","theProduct","filter","removeCartItem","callDecreaseCartItem","callRemoveCartItem","callAddCartItem"],"sources":["/Users/5e9e/Desktop/projects/web_apps/react/capston/practice-shop/src/store/cart/cart.action.js"],"sourcesContent":["import { createAction } from \"../../utils/reducer/reducer.utils\";\nimport { CART_ACTION_TYPE } from \"./cart.types\";\n\n\n// 이곳의 최종 결과물은 액션.  \n// const setData = (date) => createAction (type, data)\n\n\nexport const setCartItems = (item) => {\n   createAction(CART_ACTION_TYPE.SET_CART_ITEM, item)\n}\n\nexport const setIsCartOpen = (boolean) =>\n   createAction(CART_ACTION_TYPE.SET_IS_CART_OPEN, boolean)\n\n\n// main 함수들\n\nconst addCartItem = (productToGo, cartItems) => {\n   const existingProduct = cartItems.find((each) => (   // 기존에 있으면 퀀티티만 추가, 기존에 없으면 새로추가. 항상 배열을 건드릴때는 그 구조에 대해서 생각\n      each.id === productToGo.id\n   ))\n   if (existingProduct) {                   // 곂친경우니까 퀀티티만 더해줘야함. 나머지는 그대로 놓고 어떻게 퀀티티만 추가할거냐?\n      return cartItems.map((each) => (       // 맵을 활용할거다. 그래서 있는애면 아이디가 곂칠테니까 걔만 퀀티티+1 나머지는 안건드리고 리턴\n         each.id === productToGo.id\n            ? { ...each, quantity: each.quantity + 1 }\n            : each\n      ))\n   }\n   return [...cartItems, { ...productToGo, quantity: 1 }]\n}\n\n\nconst decreaseCartItem = (theProduct, cartItems) => {\n   if (theProduct.quantity === 1) {\n      return cartItems.filter((item) => item.id !== theProduct.id)\n   } else {\n      return cartItems.map((each) => (\n         each.id === theProduct.id\n            ? { ...each, quantity: each.quantity - 1 }\n            : each\n      ))\n   }\n}\n\nconst removeCartItem = (theProduct, cartItems) =>\n   cartItems.filter((item) => item.id !== theProduct.id)\n\n\n// call 함수들 \nexport const callDecreaseCartItem = (theProduct, cartItems) => {\n   setCartItems(decreaseCartItem(theProduct, cartItems))\n}\n\n\nexport const callRemoveCartItem = (theProduct, cartItems) => {\n   setCartItems(removeCartItem(theProduct, cartItems))\n}\n\nexport const callAddCartItem = (productToGo, cartItems) => {\n   setCartItems(addCartItem(productToGo, cartItems))\n}\n\n\n\n"],"mappings":"AAAA,SAASA,YAAT,QAA6B,mCAA7B;AACA,SAASC,gBAAT,QAAiC,cAAjC,C,CAGA;AACA;;AAGA,OAAO,MAAMC,YAAY,GAAIC,IAAD,IAAU;EACnCH,YAAY,CAACC,gBAAgB,CAACG,aAAlB,EAAiCD,IAAjC,CAAZ;AACF,CAFM;AAIP,OAAO,MAAME,aAAa,GAAIC,OAAD,IAC1BN,YAAY,CAACC,gBAAgB,CAACM,gBAAlB,EAAoCD,OAApC,CADR,C,CAIP;;AAEA,MAAME,WAAW,GAAG,CAACC,WAAD,EAAcC,SAAd,KAA4B;EAC7C,MAAMC,eAAe,GAAGD,SAAS,CAACE,IAAV,CAAgBC,IAAD,IAAc;EAClDA,IAAI,CAACC,EAAL,KAAYL,WAAW,CAACK,EADH,CAAxB;;EAGA,IAAIH,eAAJ,EAAqB;IAAoB;IACtC,OAAOD,SAAS,CAACK,GAAV,CAAeF,IAAD,IAAkB;IACpCA,IAAI,CAACC,EAAL,KAAYL,WAAW,CAACK,EAAxB,GACK,EAAE,GAAGD,IAAL;MAAWG,QAAQ,EAAEH,IAAI,CAACG,QAAL,GAAgB;IAArC,CADL,GAEKH,IAHD,CAAP;EAKF;;EACD,OAAO,CAAC,GAAGH,SAAJ,EAAe,EAAE,GAAGD,WAAL;IAAkBO,QAAQ,EAAE;EAA5B,CAAf,CAAP;AACF,CAZD;;AAeA,MAAMC,gBAAgB,GAAG,CAACC,UAAD,EAAaR,SAAb,KAA2B;EACjD,IAAIQ,UAAU,CAACF,QAAX,KAAwB,CAA5B,EAA+B;IAC5B,OAAON,SAAS,CAACS,MAAV,CAAkBhB,IAAD,IAAUA,IAAI,CAACW,EAAL,KAAYI,UAAU,CAACJ,EAAlD,CAAP;EACF,CAFD,MAEO;IACJ,OAAOJ,SAAS,CAACK,GAAV,CAAeF,IAAD,IAClBA,IAAI,CAACC,EAAL,KAAYI,UAAU,CAACJ,EAAvB,GACK,EAAE,GAAGD,IAAL;MAAWG,QAAQ,EAAEH,IAAI,CAACG,QAAL,GAAgB;IAArC,CADL,GAEKH,IAHD,CAAP;EAKF;AACH,CAVD;;AAYA,MAAMO,cAAc,GAAG,CAACF,UAAD,EAAaR,SAAb,KACpBA,SAAS,CAACS,MAAV,CAAkBhB,IAAD,IAAUA,IAAI,CAACW,EAAL,KAAYI,UAAU,CAACJ,EAAlD,CADH,C,CAIA;;;AACA,OAAO,MAAMO,oBAAoB,GAAG,CAACH,UAAD,EAAaR,SAAb,KAA2B;EAC5DR,YAAY,CAACe,gBAAgB,CAACC,UAAD,EAAaR,SAAb,CAAjB,CAAZ;AACF,CAFM;AAKP,OAAO,MAAMY,kBAAkB,GAAG,CAACJ,UAAD,EAAaR,SAAb,KAA2B;EAC1DR,YAAY,CAACkB,cAAc,CAACF,UAAD,EAAaR,SAAb,CAAf,CAAZ;AACF,CAFM;AAIP,OAAO,MAAMa,eAAe,GAAG,CAACd,WAAD,EAAcC,SAAd,KAA4B;EACxDR,YAAY,CAACM,WAAW,CAACC,WAAD,EAAcC,SAAd,CAAZ,CAAZ;AACF,CAFM"},"metadata":{},"sourceType":"module"}